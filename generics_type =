02transpile.c:                fprintf(stderr, "%s %d: output source file faield\n", info->sname, info->sline);
02transpile.c:                fprintf(stderr, "transpile error. err num %d\n", info->err_num);
03transpile2.c:    if(info->no_output_come_code) {
03transpile2.c:    if(info->come_fun) {
03transpile2.c:        for(i=0; i<info->block_level; i++) {
03transpile2.c:    if(info->no_output_come_code) {
03transpile2.c:    if(info->no_output_come_code) {
03transpile2.c:        info->come_fun->mSourceHead.append_str(msg2);
03transpile2.c:    if(info->no_output_come_code) {
03transpile2.c:        info->come_fun->mSourceHead2.append_str(msg2);
03transpile2.c:    if(info->no_output_come_code) {
03transpile2.c:    if(info->no_output_come_code) {
03transpile2.c:    if(info->no_output_come_code) {
04heap.c:    if(info->no_output_come_code) {
04heap.c:    new_value.mFunName = clone info->come_fun->mName;
04heap.c:    new_value.mBlockLevel = info->block_level;
04heap.c:    foreach(it, info->right_value_objects) {
04heap.c:    info->right_value_objects.delete(i, i+1);
04heap.c:    var right_value_objects = info->right_value_objects;
04heap.c:            finalizer = info->funcs[fun_name2];
04heap.c:                sGenericsFun* generics_fun = info->generics_funcs[generics_fun_name];
04heap.c:                        fprintf(stderr, "%s %d: can't create generics finalizer\n", info->sname, info->sline);
04heap.c:                    finalizer = info->funcs[fun_name2];
04heap.c:                finalizer = info->funcs[new_fun_name];
04heap.c:                finalizer = info->funcs[fun_name2];
04heap.c:    var right_value_objects = info->right_value_objects;
04heap.c:        cloner = info->funcs[fun_name2];
04heap.c:            cloner = info->funcs[new_fun_name];
04heap.c:            cloner = info->funcs[fun_name2];
04heap.c:    var right_value_objects = info->right_value_objects;
04heap.c:        cloner = info->funcs[fun_name2];
04heap.c:            cloner = info->funcs[new_fun_name];
04heap.c:            cloner = info->funcs[fun_name2];
04heap.c:    var right_value_objects = info->right_value_objects;
04heap.c:        cloner = info->funcs[fun_name2];
04heap.c:            cloner = info->funcs[new_fun_name];
04heap.c:            cloner = info->funcs[fun_name2];
04heap.c:    var right_value_objects = info->right_value_objects;
04heap.c:        cloner = info->funcs[fun_name2];
04heap.c:            cloner = info->funcs[new_fun_name];
04heap.c:            cloner = info->funcs[fun_name2];
04heap.c:    var right_value_objects = info->right_value_objects;
04heap.c:            if(it->mFunName === info->come_fun->mName && it->mBlockLevel == info->block_level) {
04heap.c:                type = solve_type(type, info->generics_type, info->method_generics_types, info).catch
04heap.c:    foreach(it, info->right_value_objects) {
04heap.c:    sVarTable* it = info->lv_table;
04heap.c:    if(it == info->come_fun->mBlock->mVarTable) {
04heap.c:        while(it != info->come_fun->mBlock->mVarTable) {
05function.c:    while(*info->p == '#') {
05function.c:        info->p++;
05function.c:        if(xisdigit(*info->p)) {
05function.c:            while(xisdigit(*info->p)) {
05function.c:                line = line * 10 + (*info->p - '0');
05function.c:                info->p++;
05function.c:            if(*info->p == '"') {
05function.c:                info->p++;
05function.c:                while(*info->p != '"') {
05function.c:                    *p = *info->p;
05function.c:                    info->p++;
05function.c:                while(*info->p != '\n') {
05function.c:                    info->p++;
05function.c:                info->p++;
05function.c:            info->sline = line;
05function.c:            info->sname = string(fname);
05function.c:        else if(*info->p == '"') {
05function.c:            info->p++;
05function.c:            while(*info->p != '"') {
05function.c:                info->p++;
05function.c:            while(*info->p != '\n') {
05function.c:                info->p++;
05function.c:            info->p++;
05function.c:    while((*info->p >= 'a' && *info->p <= 'z') || (*info->p >= 'A' && *info->p <= 'Z') || *info->p == '_' || (*info->p >= '0' && *info->p <= '9') || (*info->p == '$'))
05function.c:        buf.append_char(*info->p);
05function.c:        info->p++;
05function.c:        err_msg(info, "unexpected character(%c)\n", *info->p);
05function.c:        if(*info->p == ' ' || *info->p == '\t') {
05function.c:            info->p++;
05function.c:        else if(*info->p == '\n') {
05function.c:            info->p++;
05function.c:            info->sline++;
05function.c:            if(*info->p == ')') {
05function.c:            if(*info->p == ')') {
05function.c:                info->p++;
05function.c:            if(*info->p == ')') {
05function.c:                info->p++;
05function.c:            var param_type2 = solve_generics(param_type, info->generics_type, info) throws;
05function.c:            if(*info->p == '=') {
05function.c:                info->p++;
05function.c:                char* p = info->p;
05function.c:                char* p2 = info->p;
05function.c:            if(*info->p == ',') {
05function.c:                info->p++;
05function.c:                    info->p += strlen("...");
05function.c:            else if(*info->p == ')') {
05function.c:                info->p++;
05function.c:            if(*info->p == '{') {
05function.c:                if(*info->p == ';') {
05function.c:            if(*info->p == '<') {
05function.c:                info->p++;
05function.c:                    if(*info->p == '>') {
05function.c:                        info->p++;
05function.c:                        if(*info->p == '{') {
05function.c:                    else if(*info->p == '\0') {
05function.c:                        info->p++;
05function.c:            if(*info->p == '{') {
05function.c:                if(*info->p == ';') {
05function.c:            if(*info->p == '{') {
05function.c:                if(*info->p == ';') {
05function.c:            if(*info->p == '{') {
05function.c:                if(*info->p == ';') {
05function.c:            if(*info->p == '{') {
05function.c:                if(*info->p == ';') {
05function.c:            if(*info->p == '{') {
05function.c:                if(*info->p == ';') {
05function.c:                if(!xisalpha(*info->p)) {
05function.c:            if(*info->p == ':') {
05function.c:        if(isalpha(*info->p)) {
05function.c:            if(*info->p == '(' && info.in_typedef) {
05function.c:    if(anonymous_type && *info->p == '{') {
05function.c:            if(xisalnum(*info.p) || *info->p == '_') {
05function.c:    else if(*info->p == '(' && *(info->p+1) == '*') {
05function.c:        info->p++;
05function.c:        else if(*info->p == '<') {
05function.c:            info->p++;
05function.c:                if(*info->p == ',') {
05function.c:                    info->p++;
05function.c:                else if(*info->p == '>') {
05function.c:                    info->p++;
05function.c:                if(klass == null && *info->p != '<') {
05function.c:        if(memcmp(info->p, "const ", strlen("const ")) == 0) {
05function.c:            info->p += strlen("const ");
05function.c:        while(*info->p == '*') {
05function.c:            info->p++;
05function.c:            if(memcmp(info->p, "const ", strlen("const ")) == 0) {
05function.c:                info->p += strlen("const ");
05function.c:        if(*info->p == '%') {
05function.c:            info->p++;
05function.c:        if(*info->p == '&') {
05function.c:            info->p++;
05function.c:        if(*info->p == '?') {
05function.c:            info->p++;
05function.c:        while(*info->p == '*') {
05function.c:            info->p++;
05function.c:            if(memcmp(info->p, "const ", strlen("const ")) == 0) {
05function.c:                info->p += strlen("const ");
05function.c:            info->p += strlen("__restrict ");
05function.c:            info->p += strlen("restrict ");
05function.c:        if(parse_multiple_type && (*info->p == ',' || exception_)) {
05function.c:            while(*info->p == ',') {
05function.c:                info->p++;
05function.c:            if(xisalnum(*info.p) || *info->p == '_') {
05function.c:    while(*info->p == '[') {
05function.c:        info->p++;
05function.c:        if(*info->p == ']') {
05function.c:            info->p++;
05function.c:    self.sline = info->sline;
05function.c:    self.sname = string(info->sname);
05function.c:    self.sline = info->sline;
05function.c:    self.sname = string(info->sname);
05function.c:    self.sline = info->sline;
05function.c:    self.sname = string(info->sname);
05function.c:    self.sline = info->sline;
05function.c:    self.sname = string(info->sname);
05function.c:    self.sline = info->sline;
05function.c:    self.sname = string(info->sname);
05function.c:    self.sline = info->sline;
05function.c:    self.sname = string(info->sname);
05function.c:    info->last_statment_is_return = true;
05function.c:    err_msg(info, "invalid character(%c)(1)\n", *info->p);
05function.c:        if(*info->p == ')') {
05function.c:            info->p++;
05function.c:        if(err_flag == false && *info->p == ':') {
05function.c:            info->p++;
05function.c:            info->p = p;
05function.c:            info->sline = sline;
05function.c:        if(*info->p == ',') {
05function.c:            info->p++;
05function.c:        else if(*info->p == ')') {
05function.c:            info->p++;
05function.c:    if(xisdigit(*info->p)) {
05function.c:        while(xisdigit(*info->p) || *info->p == '_') {
05function.c:            if(*info->p ==  '_') {
05function.c:                info->p++;
05function.c:                *p2++ = *info->p;
05function.c:                info->p++;
05function.c:        char c = *(info->p+1);
05function.c:        if(*info->p == '.' && xisdigit(c)) {
05function.c:            *p2++ = *info->p;
05function.c:            info->p++;
05function.c:            while(xisdigit(*info->p) || *info->p == '_') {
05function.c:                if(*info->p ==  '_') {
05function.c:                    info->p++;
05function.c:                    *p2++ = *info->p;
05function.c:                    info->p++;
05function.c:            if(*info->p == 'e') {
05function.c:                *p2++ = *info->p;
05function.c:                info->p++;
05function.c:                if(*info->p == '+') {
05function.c:                    *p2++ = *info->p;
05function.c:                    info->p++;
05function.c:                else if(*info->p == '-') {
05function.c:                    *p2++ = *info->p;
05function.c:                    info->p++;
05function.c:                while(xisdigit(*info->p) || *info->p == '_') {
05function.c:                    if(*info->p ==  '_') {
05function.c:                        info->p++;
05function.c:                        *p2++ = *info->p;
05function.c:                        info->p++;
05function.c:            if(*info->p == 'f' || *info->p == 'F') {
05function.c:                info->p++;
05function.c:            else if(*info->p == 'l' || *info->p == 'L') {
05function.c:                info->p++;
05function.c:        else if(*info->p == 'u' || *info->p == 'U')
05function.c:            info->p++;
05function.c:            if(*info->p == 'L' || *info->p == 'l')
05function.c:                info->p++;
05function.c:                if(*info->p == 'L' || *info->p == 'l')
05function.c:                    info->p++;
05function.c:        else if(*info->p == 'L' || *info->p == 'l') {
05function.c:            info->p++;
05function.c:            if(*info->p == 'L' || *info->p == 'l')
05function.c:                info->p++;
05function.c:            else if(*info->p == 'U' || *info->p == 'u')
05function.c:                info->p++;
05function.c:    while((*info->p >= '0' && *info->p <= '9') || (*info->p >= 'a' && *info->p <= 'f') || (*info->p >= 'A' && *info->p <= 'F') || *info->p == '_') 
05function.c:        if(*info->p == '_') {
05function.c:            info->p++;
05function.c:            *p++ = *info->p;
05function.c:            info->p++;
05function.c:    if(*info->p == 'u' || *info->p == 'U')
05function.c:        info->p++;
05function.c:        if(*info->p == 'L' || *info->p == 'l')
05function.c:            info->p++;
05function.c:            if(*info->p == 'L' || *info->p == 'l')
05function.c:                info->p++;
05function.c:    else if(*info->p == 'L' || *info->p == 'l') {
05function.c:        info->p++;
05function.c:        if(*info->p == 'L' || *info->p == 'l')
05function.c:            info->p++;
05function.c:        else if(*info->p == 'U' || *info->p == 'u')
05function.c:            info->p++;
05function.c:    while((*info->p >= '0' && *info->p <= '7') || *info->p == '_') {
05function.c:        if(*info->p == '_') {
05function.c:            info->p++;
05function.c:            *p = *info->p;
05function.c:            info->p++;
05function.c:    if(*info->p == 'u' || *info->p == 'U')
05function.c:        info->p++;
05function.c:        if(*info->p == 'L' || *info->p == 'l')
05function.c:            info->p++;
05function.c:            if(*info->p == 'L' || *info->p == 'l')
05function.c:                info->p++;
05function.c:    else if(*info->p == 'L' || *info->p == 'l') {
05function.c:        info->p++;
05function.c:        if(*info->p == 'L' || *info->p == 'l')
05function.c:            info->p++;
05function.c:        else if(*info->p == 'U' || *info->p == 'u')
05function.c:            info->p++;
05function.c:    self.sline = info->sline;
05function.c:    self.sname = string(info->sname);
05function.c:    self.sline = info->sline;
05function.c:    self.sname = string(info->sname);
05function.c:    self.sline = info->sline;
05function.c:    self.sname = string(info->sname);
05function.c:    self.sline = info->sline;
05function.c:    self.sname = string(info->sname);
05function.c:    self.sline = info->sline;
05function.c:    self.sname = string(info->sname);
05function.c:    if(*info->p == '{') {
05function.c:    else if(*info->p == '!') {
05function.c:        info->p++;
05function.c:    else if(*info->p == '-' && *(info->p+1) == '-') {
05function.c:        info->p+=2;
05function.c:    else if(*info->p == '-') {
05function.c:        info->p++;
05function.c:    else if(*info->p == '+' && *(info->p+1) == '+') {
05function.c:        info->p+=2;
05function.c:    else if(*info->p == '~') {
05function.c:        info->p++;
05function.c:    else if(*info->p == '0' && (*(info->p+1) == 'x' || *(info->p+1) == 'X')) {
05function.c:        info->p += 2;
05function.c:    else if(*info->p == '0' && xisdigit(*(info->p+1))) {
05function.c:        info->p++;
05function.c:    else if(xisdigit(*info->p)) {
05function.c:    else if(*info->p == '-' && xisdigit(*(info->p+1))) {
05function.c:        info->p++;
05function.c:        info->p += strlen("return");
05function.c:        if(*info->p == ';') {
05function.c:        info->p += strlen("throw");
05function.c:    else if(*info->p == '*') {
05function.c:        info->p ++;
05function.c:    else if(*info->p == '&') {
05function.c:        info->p ++;
05function.c:    else if(*info->p == '!') {
05function.c:        info->p ++;
05function.c:    else if(xisalpha(*info->p) || *info->p == '_') {
05function.c:            if(xisalpha(*info->p) || *info->p == '_') {
05function.c:        if(buf !== "if" && buf !== "while" && buf !== "for" && buf !== "switch" && buf !== "return" && buf !== "sizeof" && buf !== "isheap" && buf !== "gc_inc" && buf !== "gc_dec" && *info->p == '(' && *(info->p+1) != '*')
05function.c:            if(*info->p == '(') {
05function.c:                info->p++;
05function.c:                if(*info->p == '*') {
05function.c:                    info->p++;
05function.c:        if(buf !== "if" && buf !== "while" && buf !== "for" && buf !== "switch" && buf !== "return" && buf !== "sizeof" && buf !== "isheap" && buf !== "gc_inc" && buf !== "gc_dec" && *info->p == '(' && *(info->p+1) != '*')
05function.c:        else if((buf === "string" || buf === "wstring") && *info->p == '(') {
05function.c:        else if(buf !== "if" && buf !== "while" && buf !== "for" && buf !== "switch" && buf !== "return" && buf !== "sizeof" && buf !== "isheap" && buf !== "gc_inc" && buf !== "gc_dec" && *info->p == '(' && !(*(info->p+1) == '*' && is_type_name_))
05function.c:    else if(*info->p == '(') {
05function.c:        info->p++;
05function.c:            if(*info->p == ',') {
05function.c:    err_msg(info, "unexpected operator(%c)\n", *info->p);
05function.c:    int block_level = info->block_level;
05function.c:        info->block_level++;
05function.c:    if(*info->p == '{') {
05function.c:        info->p++;
05function.c:            if(*info->p == '}') {
05function.c:                info->p++;
05function.c://            add_come_code(info, xsprintf("# %d \"%s\"\n", info->sline, info->sname));
05function.c:            while(*info->p == ';') {
05function.c:                info->p++;
05function.c:            if(*info->p == '}') {
05function.c:                info->p++;
05function.c:    info->block_level = block_level;
05function.c:    sVarTable* old_table = info->lv_table;
05function.c:        info->lv_table = block->mVarTable;
05function.c:    int block_level = info->block_level;
05function.c:        info->block_level++;
05function.c:            int stack_num_before = info->stack.length();
05function.c:            info->last_statment_is_return = false;
05function.c:    if(!info->last_statment_is_return && !no_var_table) {
05function.c:        free_objects(info->lv_table, null!, info);
05function.c:    info->lv_table = old_table;
05function.c:    info->block_level = block_level;
05function.c:    if(info->stack.length() > top) {
05function.c:        dec_stack_ptr(info->stack.length()-top, info);
05function.c:    if(info->stack.length() < top) {
05function.c:        fprintf(stderr, "%s %d: unexpected stack value. The stack num is %d. top is %d\n", info->sname, info->sline, info->stack.length(), top);
05function.c:    if(*info->p != c) {
05function.c:        err_msg(info, "expected next charaster is %c, but %c\n", c, *info->p);
05function.c:    info->p++;
05function.c:    var generics_type_saved = clone info->generics_type;
05function.c:    info->generics_type = clone generics_type;
05function.c:    var generics_type_names_saved = clone info->generics_type_names;
05function.c:    info->generics_type_names = clone generics_fun.mGenericsTypeNames;
05function.c:    info->generics_type = generics_type_saved;
05function.c:    info->generics_type_names = generics_type_names_saved;
05function.c:    if(*info->p == '{') {
05function.c:        info->p++;
05function.c:                if(*info->p == '\\') {
05function.c:                    info->p++;
05function.c:                    if(*info->p == '\0') {
05function.c:                        err_msg(info, "%s %d: unexpected the source end. close single quote or double quote.", info->sname, sline);
05function.c:                    info->p++;
05function.c:                else if(*info->p == '"') {
05function.c:                    info->p++;
05function.c:                    info->p++;
05function.c:                    if(*info->p == '\0') {
05function.c:                        err_msg(info, "%s %d: unexpected the source end. close single quote or double quote.", info->sname, sline);
05function.c:                if(*info->p == '\\') {
05function.c:                    info->p++;
05function.c:                    if(*info->p == '\0') {
05function.c:                        err_msg(info, "%s %d: unexpected the source end. close single quote or double quote.", info->sname, sline);
05function.c:                    info->p++;
05function.c:                else if(*info->p == '\'') {
05function.c:                    info->p++;
05function.c:                    info->p++;
05function.c:                    if(*info->p == '\0') {
05function.c:                        err_msg(info, "%s %d: unexpected the source end. close single quote or double quote.", info->sname, sline);
05function.c:            else if(*info->p == '\'') {
05function.c:                sline = info->sline;
05function.c:                info->p++;
05function.c:            else if(*info->p == '"') {
05function.c:                sline = info->sline;
05function.c:                info->p++;
05function.c:            else if(*info->p == '#') {
05function.c:            else if(*info->p == '{') {
05function.c:                info->p++;
05function.c:            else if(*info->p == '}') {
05function.c:                info->p++;
05function.c:            else if(*info->p == '\0') {
05function.c:            else if(*info->p == '\n') {
05function.c:                info->p++;
05function.c:                info->sline++;
05function.c:                info->p++;
05function.c:        err_msg(info, "Require block. This is %c", *info->p);
05function.c:        if(memcmp(info->p, "__attribute_pure__", strlen("__attribute_pure__")) == 0) {
05function.c:            info->p += strlen("__attribute_pure__");
05function.c:        else if(memcmp(info->p, "__attribute_malloc__", strlen("__attribute_malloc__")) == 0) {
05function.c:            info->p += strlen("__attribute_malloc__");
05function.c:        else if(memcmp(info->p, "__attr_dealloc_fclose", strlen("__attr_dealloc_fclose")) == 0) {
05function.c:            info->p += strlen("__attr_dealloc_fclose");
05function.c:        else if(memcmp(info->p, "__wur", strlen("__wur")) == 0) {
05function.c:            info->p += strlen("__wur");
05function.c:        else if(memcmp(info->p, "__noreturn", strlen("__noreturn")) == 0) {
05function.c:            info->p += strlen("__noreturn");
05function.c:        else if(memcmp(info->p, "__attribute__", strlen("__attribute__")) == 0) {
05function.c:            info->p += strlen("__attribute__");
05function.c:            while(*info->p) {
05function.c:                if(*info->p == '(') {
05function.c:                    info->p++;
05function.c:                else if(*info->p == ')') {
05function.c:                    info->p++;
05function.c:                    info->p++;
05function.c:        else if(memcmp(info->p, "__asm__", strlen("__asm__")) == 0) {
05function.c:            info->p += strlen("__asm__");
05function.c:            while(*info->p) {
05function.c:                if(*info->p == '"') {
05function.c:                    info->p++;
05function.c:                    asm_fun_name.append_char(*info->p);
05function.c:                    info->p++;
05function.c:                else if(*info->p == '(') {
05function.c:                    info->p++;
05function.c:                else if(*info->p == ')') {
05function.c:                    info->p++;
05function.c:                    info->p++;
05function.c:        else if(memcmp(info->p, "__asm", strlen("__asm")) == 0) {
05function.c:            info->p += strlen("__asm");
05function.c:            if(*info->p == '(') {
05function.c:                info->p++;
05function.c:            while(*info->p) {
05function.c:                if(*info->p == '"') {
05function.c:                    info->p++;
05function.c:                        info->p++;
05function.c:                        asm_fun_name.append_char(*info->p);
05function.c:                else if(*info->p == ')') {
05function.c:                    info->p++;
05function.c:                    info->p++;
05function.c:        else if(memcmp(info->p, "__asm", strlen("__asm")) == 0) {
05function.c:            info->p += strlen("__asm");
05function.c:            while(*info->p) {
05function.c:                if(*info->p == '(') {
05function.c:                    info->p++;
05function.c:                else if(*info->p == ')') {
05function.c:                    info->p++;
05function.c:                    info->p++;
05function.c:        while(xisalnum(*info->p) || *info->p == '_') {
05function.c:            buf2.append_char(*info->p);
05function.c:            info->p++;
05function.c:        while(*info->p == '*') {
05function.c:            info->p++;
05function.c:        while(*info->p == '%') {
05function.c:            info->p++;
05function.c:        if(buf2.length() > 0 && *info->p == ':' && *(info->p+1) == ':') {
05function.c:    else if(info->impl_type) {
05function.c:        fun_name = create_method_name(info->impl_type, false@no_pointer_name, base_fun_name, info);
05function.c:    if(memcmp(info->p, "version", strlen("version")) == 0) {
05function.c:        info->p += strlen("version");
05function.c:        while(xisdigit(*info->p)) {
05function.c:            n = n * 10 + (*info->p - '0');
05function.c:            info->p++;
05function.c:    else if(*info->p == '{') {
05function.c:    else if(xisalpha(*info->p) || *info->p == '_' || *info->p == ';') {
05function.c:        if(*info->p == ';') {
05function.c:            info->p++;
05function.c:        err_msg(info, "invalid character(%c)(2)\n", *info->p);
05function.c:    if(*info->p == '=') {
05function.c:        info->p++;
05function.c:        if(*info->p == '{') {
05function.c:            buf.append_char(*info->p);
05function.c:            info->p++;
05function.c:                if(*info->p == '\0') {
05function.c:                else if(*info->p == '\\') {
05function.c:                    buf.append_char(*info->p);
05function.c:                    info->p++;
05function.c:                    buf.append_char(*info->p);
05function.c:                    info->p++;
05function.c:                else if(!squort && *info->p == '"') {
05function.c:                    buf.append_char(*info->p);
05function.c:                    info->p++;
05function.c:                else if(!dquort && *info->p == '\'') {
05function.c:                    buf.append_char(*info->p);
05function.c:                    info->p++;
05function.c:                    buf.append_char(*info->p);
05function.c:                    info->p++;
05function.c:                else if(*info->p == '{') {
05function.c:                    buf.append_char(*info->p);
05function.c:                    info->p++;
05function.c:                else if(*info->p == '}') {
05function.c:                    buf.append_char(*info->p);
05function.c:                    info->p++;
05function.c:                    buf.append_char(*info->p);
05function.c:                    info->p++;
05function.c:            if(xisalnum(*info.p) || *info->p == '_') {
05function.c:                    while(*info->p == '*') {
05function.c:                        info->p++;
05function.c:                    if(*info->p == '%') {
05function.c:                        info->p++;
05function.c:                    if(*info->p == ':') {
05function.c:                        info->p++;
05function.c:                    if(*info->p == ':') {
05function.c:                        info->p++;
05function.c:                    if(xisalnum(*info.p) || *info->p == '_') {
05function.c:                if(strlen(word) > 0 && (*info->p == '(' || (*info->p == ':' && *(info->p+1) == ':'))) {
05function.c:            if(!xisalpha(*info->p)) {
05function.c:            while(xisalpha(*info->p) || *info->p == '_') {
05function.c:                info->p++;
05function.c:            if(*info->p == '(' || *info->p == ':') {
05function.c:    while(*info->p) {
05function.c:        while(*info->p == ';') {
05function.c:            info->p++;
06str.c:    self.sname = string(info->sname);
06str.c:    self.sline = info->sline;
06str.c:    self.sname = string(info->sname);
06str.c:    self.sline = info->sline;
06str.c:    self.sname = string(info->sname);
06str.c:    self.sname = string(info->sname);
06str.c:    self.sname = string(info->sname);
06str.c:    info->no_output_come_code = true;
06str.c:    info->no_output_come_code = false;
06str.c:    self.sname = string(info->sname);
06str.c:        info->no_output_come_code = true;
06str.c:        info->no_output_come_code = false;
06str.c:    self.sname = string(info->sname);
06str.c:    info->no_output_come_code = true;
06str.c:    info->no_output_come_code = false;
06str.c:    info->no_output_come_code = true;
06str.c:    info->no_output_come_code = false;
06str.c:    if(*info->p == '"') 
06str.c:        info->p++;
06str.c:        int sline = info->sline;
06str.c:            if(*info->p == '"') {
06str.c:                info->p++;
06str.c:                char* p = info->p;
06str.c:                int sline = info->sline;
06str.c:                if(*info->p == '"') {
06str.c:                    info->p++;
06str.c:                    info->p = p;
06str.c:                    info->sline = sline;
06str.c:            else if(*info->p == '\\') {
06str.c:                info->p++;
06str.c:                if(*info->p == '"') {
06str.c:                    info->p++;
06str.c:                    value.append_char(*info->p);
06str.c:                    info->p++;
06str.c:            else if(*info->p == '\0') {
06str.c:                int sline2 = info->sline;
06str.c:                info->sline = sline;
06str.c:                info->sline = sline2;
06str.c:                if(*info->p == '\n') info->sline++;
06str.c:                value.append_char(*info->p);
06str.c:                info->p++;
06str.c:    else if(*info->p == '\'') {
06str.c:        info->p++;
06str.c:        if(*info->p == '\\') {
06str.c:            info->p++;
06str.c:            if(xisdigit(*info->p)) {
06str.c:                while(xisdigit(*info->p)) {
06str.c:                    n = n * 8 + *info->p - '0';
06str.c:                    info->p++;
06str.c:                switch(*info->p) {
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        if(xisdigit(*info->p)) {
06str.c:                            while(xisdigit(*info->p)) {
06str.c:                                n = n * 8 + *info->p - '0';
06str.c:                                info->p++;
06str.c:                        info->p++;
06str.c:                        while(*info->p >= '0' && *info->p <= '9' || *info->p >= 'a' && *info->p <= 'f' || *info->p >= 'A' && *info->p <= 'F') {
06str.c:                            buf2[0] = *info->p;
06str.c:                            info->p++;
06str.c:                        c = *info->p;
06str.c:                        info->p++;
06str.c:            c = *info->p;
06str.c:            info->p++;
06str.c:        if(*info->p != '\'') {
06str.c:            info->p++;
06str.c:    else if(*info->p == 'L' && *(info->p+1) == '\'') {
06str.c:        info->p+=2;
06str.c:        if(*info->p == '\\') {
06str.c:            info->p++;
06str.c:            if(xisdigit(*info->p)) {
06str.c:                while(xisdigit(*info->p)) {
06str.c:                    n = n * 8 + *info->p - '0';
06str.c:                    info->p++;
06str.c:                switch(*info->p) {
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        info->p++;
06str.c:                        if(xisdigit(*info->p)) {
06str.c:                            while(xisdigit(*info->p)) {
06str.c:                                n = n * 8 + *info->p - '0';
06str.c:                                info->p++;
06str.c:                        info->p++;
06str.c:                        while(*info->p >= '0' && *info->p <= '9' || *info->p >= 'a' && *info->p <= 'f' || *info->p >= 'A' && *info->p <= 'F') {
06str.c:                            buf2[0] = *info->p;
06str.c:                            info->p++;
06str.c:                        c = *info->p;
06str.c:                        info->p++;
06str.c:            unsigned char p2 = *(unsigned char*)info->p;
06str.c:                    info->err_num++;
06str.c:                    memcpy(str, info->p, size);
06str.c:                        info->err_num++;
06str.c:                    info->p += size;
06str.c:                c = *info->p;
06str.c:                info->p++;
06str.c:        if(*info->p != '\'') {
06str.c:            info->err_num++;
06str.c:            info->p++;
06str.c:    else if(*info->p == 'L' && *(info->p+1) == '"') {
06str.c:        info->p+=2;
06str.c:        int sline = info->sline;
06str.c:            if(*info->p == '"') {
06str.c:                info->p++;
06str.c:                char* p = info->p;
06str.c:                int sline = info->sline;
06str.c:                if(*info->p == '"') {
06str.c:                    info->p++;
06str.c:                    info->p = p;
06str.c:                    info->sline = sline;
06str.c:            else if(*info->p == '\\') {
06str.c:                info->p++;
06str.c:                if(xisdigit(*info->p)) {
06str.c:                    while(xisdigit(*info->p) && len < 3) {
06str.c:                        n = n * 8 + *info->p - '0';
06str.c:                        info->p++;
06str.c:                else if(*info->p == 'x' || *info->p == 'X') {
06str.c:                    info->p++;
06str.c:                    while(*info->p >= '0' && *info->p <= '9' || *info->p >= 'a' && *info->p <= 'f' || *info->p >= 'A' && *info->p <= 'F') {
06str.c:                        buf2[0] = *info->p;
06str.c:                        info->p++;
06str.c:                    switch(*info->p) {
06str.c:                            info->p++;
06str.c:                            info->p++;
06str.c:                            info->p++;
06str.c:                            info->p++;
06str.c:                            info->p++;
06str.c:                            info->p++;
06str.c:                            info->p++;
06str.c:                            info->p++;
06str.c:                            info->p++;
06str.c:                            value.append_char(*info->p);
06str.c:                            info->p++;
06str.c:            else if(*info->p == '\0') {
06str.c:                int sline2 = info->sline;
06str.c:                info->sline = sline;
06str.c:                if(*info->p == '\n') info->sline++;
06str.c:                value.append_char(*info->p);
06str.c:                info->p++;
06str.c:    else if(*info->p == '[') {
06str.c:        info->p++;
06str.c:        if(*info->p == ':') {
06str.c:            info->p++;
06str.c:            if(*info->p == ']') {
06str.c:                info->p++;
06str.c:                    if(*info->p == '\0') {
06str.c:                    else if(*info->p == ',') {
06str.c:                        info->p++;
06str.c:                    else if(*info->p == ']') {
06str.c:                        info->p++;
06str.c:                        err_msg(info, "invalid character(%c)(3)", *info->p);
06str.c:        else if(*info->p == ']') {
06str.c:            info->p++;
06str.c:        else if(*info->p == ',') {
06str.c:            info->p++;
06str.c:                if(*info->p == '\0') {
06str.c:                else if(*info->p == ',') {
06str.c:                    info->p++;
06str.c:                else if(*info->p == ']') {
06str.c:                    info->p++;
06str.c:                    err_msg(info, "invalid character(%c)(4)", *info->p);
06str.c:            err_msg(info, "invalid character(%c)(5)", *info->p);
06str.c:        if(*info->p == ',') {
06str.c:            info->p++;
06str.c:        else if(*info->p == ')') {
06str.c:            info->p++;
06str.c:            err_msg(info, "invalid character(%c) in tuple expression", *info->p);
07var.c:    self.sline = info->sline;
07var.c:    self.sname = string(info->sname);
07var.c:            var type = solve_generics(self.type, info->generics_type, info).catch {
07var.c:                    var type = solve_generics(self.type, info->generics_type, info).catch {
07var.c:        sClass* current_stack_frame_struct = info->current_stack_frame_struct;
07var.c:    self.sline = info->sline;
07var.c:    self.sname = string(info->sname);
07var.c:    sClass* current_stack_frame_struct = info->current_stack_frame_struct;
07var.c:    self.sline = info->sline;
07var.c:    self.sname = string(info->sname);
07var.c:    self->mBlockLevel = info->block_level;
07var.c:    self->mBlockLevel = info->block_level;
07var.c:    self->mBlockLevel = info->block_level;
07var.c:        if(*info->p == ',' ) {
07var.c:            while(*info->p == ',') {
07var.c:                info->p++;
07var.c:        if(*info->p == '=' && *(info->p+1) != '=') {
07var.c:            err_msg(info, "var requires a right value(%c)", *info->p);
07var.c:    else if(!is_type_name_flag && *info->p == '=' && *(info->p+1) != '=') {
07var.c:            if(*info->p == '=') {
08if.c:        string sname = clone info->sname;
08if.c:        int sline = info->sline;
08if.c:            char* saved_p = info->p;
08if.c:            int saved_sline = info->sline;
08if.c:            if(!xisalpha(*info->p)) {
08if.c:                    info->p+=strlen("if");
08if.c:                info->p = saved_p;
08if.c:                info->sline = saved_sline;
09while.c:        string sname = clone info->sname;
09while.c:        int sline = info->sline;
10do_while.c:        string sname = clone info->sname;
10do_while.c:        int sline = info->sline;
11for.c:    sVarTable* lv_table = info->lv_table;
11for.c:    info->lv_table = for_var_table;
11for.c:    info->lv_table = lv_table;
13op.c:            operator_fun = info->funcs[fun_name2];
13op.c:            operator_fun = info->funcs[fun_name2];
13op.c:            operator_fun = info->funcs[new_fun_name];
13op.c:            operator_fun = info->funcs[fun_name2];
13op.c:    while(*info->p) {
13op.c:        if(!node.terminated->() && *info->p == '*' && *(info->p+1) != '=') {
13op.c:            info->p++;
13op.c:        else if(*info->p == '/' && *(info->p+1) != '=') {
13op.c:            info->p++;
13op.c:        else if(*info->p == '%' && *(info->p+1) != '=') {
13op.c:            info->p++;
13op.c:    while(*info->p) {
13op.c:        if(*info->p == '+' && *(info->p+1) != '=' && *(info->p+1) != '+') 
13op.c:            info->p++;
13op.c:        else if(*info->p == '-' && *(info->p+1) != '=' && *(info->p+1) != '-' && *(info->p+1) != '>') 
13op.c:            info->p++;
13op.c:    while(*info->p) {
13op.c:        if(*info->p == '<' && *(info->p+1) == '<' && *(info->p+2) != '=') {
13op.c:            info->p+=2;
13op.c:        else if(*info->p == '>' && *(info->p+1) == '>' && *(info->p+2) != '=' && *(info->p+2) != '>') {
13op.c:            info->p+=2;
13op.c:    while(*info->p) {
13op.c:        if(*info->p == '>' && *(info->p+1) == '=') {
13op.c:            info->p+=2;
13op.c:        else if(*info->p == '<' && *(info->p+1) == '=') {
13op.c:            info->p+=2;
13op.c:        else if(*info->p == '>' && *(info->p+1) != '>') {
13op.c:            info->p++;
13op.c:        else if(*info->p == '<' && *(info->p+1) != '<') {
13op.c:            info->p++;
13op.c:    while(*info->p) {
13op.c:        if(*info->p == '=' && *(info->p+1) == '=' && *(info->p+2) == '=') {
13op.c:            info->p+=3;
13op.c:        else if(*info->p == '=' && *(info->p+1) == '=') {
13op.c:            info->p+=2;
13op.c:        else if(*info->p == '!' && *(info->p+1) == '=' && *(info->p+2) == '=') {
13op.c:            info->p+=3;
13op.c:        else if(*info->p == '!' && *(info->p+1) == '=') {
13op.c:            info->p+=2;
13op.c:    while(*info->p) {
13op.c:        if(*info->p == '&' && *(info->p+1) != '&' && *(info->p+1) != '=') {
13op.c:            info->p++;
13op.c:    while(*info->p) {
13op.c:        if(*info->p == '^' && *(info->p+1) != '=') {
13op.c:            info->p++;
13op.c:    while(*info->p) {
13op.c:        if(*info->p == '|' && *(info->p+1) != '=' && *(info->p+1) != '|') {
13op.c:            info->p++;
13op.c:    while(*info->p) {
13op.c:        if(*info->p == '&' && *(info->p+1) == '&') {
13op.c:            info->p+=2;
13op.c:    while(*info->p) {
13op.c:        if(*info->p == '|' && *(info->p+1) == '|') {
13op.c:            info->p+=2;
13op.c:    while(*info->p) {
13op.c:        if(!info.no_comma && *info->p == ',') {
13op.c:            info->p++;
13op.c:    while(*info->p) {
13op.c:        if(*info->p == '?') {
13op.c:            info->p++;
13op.c:            if(*info->p == ':') {
14struct.c:        if(*info->p == '}') {
14struct.c:            info->p++;
14struct.c:        if(*info->p == ';') {
14struct.c:            info->p++;
14struct.c:            if(*info->p == '<') {
14struct.c:                info->p++;
14struct.c:                    if(*info->p == '>') {
14struct.c:                        info->p++;
14struct.c:                    else if(*info->p == ',') {
14struct.c:                        info->p++;
14struct.c:                    if(*info->p == '}') {
14struct.c:                        info->p++;
14struct.c:                    if(*info->p == '}') {
14struct.c:                        info->p++;
15union.c:        if(*info->p == '}') {
15union.c:            info->p++;
15union.c:            if(*info->p == '}') {
15union.c:                info->p++;
16enum.c:        if(*info->p == '=') {
16enum.c:            info->p++;
16enum.c:        if(*info->p == ',') {
16enum.c:            info->p++;
16enum.c:        if(*info->p == '}') {
16enum.c:            info->p++;
16enum.c:        if(*info->p == '{') {
16enum.c:            if(*info->p == '=') {
16enum.c:                info->p++;
16enum.c:            if(*info->p == ',') {
16enum.c:                info->p++;
16enum.c:            if(*info->p == '}') {
16enum.c:                info->p++;
18field.c:        operator_fun = info->funcs[fun_name2];
18field.c:            operator_fun = info->funcs[new_fun_name];
18field.c:            operator_fun = info->funcs[fun_name2];
18field.c:        if(*info->p == '[') {
18field.c:                if(*info->p == '[') {
18field.c:                    info->p++;
18field.c:                    if(*info->p == ']') {
18field.c:                        info->p++;
18field.c:            if(*info->p == '=' && *(info->p+1) != '=') {
18field.c:                info->p++;
18field.c:        else if(*info->p == '!' && *(info->p+1) != '=') {
18field.c:            info->p++;
18field.c:        else if(*info->p == '.' || (*info->p == '-' && *(info->p+1) == '>')) 
18field.c:            if(*info->p == '.') {
18field.c:                info->p++;
18field.c:                info->p+=2;
18field.c:            if(*info->p == '=' && *(info->p+1) != '=') {
18field.c:                info->p++;
18field.c:            else if(*info->p == '(' || *info->p == '{' || (*info->p == '-' && *(info->p+1) == '>' && *(info->p+2) == '(')) {
19eq.c:    if(*info->p == '+' && *(info->p+1) == '+') {
19eq.c:         info->p+=2;
19eq.c:    else if(*info->p == '-' && *(info->p+1) == '-') {
19eq.c:         info->p+=2;
19eq.c:    else if(*info->p == '+' && *(info->p+1) == '=') {
19eq.c:         info->p+=2;
19eq.c:    else if(*info->p == '-' && *(info->p+1) == '=') {
19eq.c:         info->p+=2;
19eq.c:    else if(*info->p == '*' && *(info->p+1) == '=') {
19eq.c:         info->p+=2;
19eq.c:    else if(*info->p == '/' && *(info->p+1) == '=') {
19eq.c:         info->p+=2;
19eq.c:    else if(*info->p == '%' && *(info->p+1) == '=') {
19eq.c:         info->p+=2;
19eq.c:    else if(*info->p == '<' && *(info->p+1) == '<' && *(info->p+2) == '=') {
19eq.c:         info->p+=3;
19eq.c:    else if(*info->p == '>' && *(info->p+1) == '>' && *(info->p+2) == '=') {
19eq.c:         info->p+=3;
19eq.c:    else if(*info->p == '^' && *(info->p+1) == '=') {
19eq.c:         info->p+=2;
19eq.c:    else if(*info->p == '&' && *(info->p+1) == '=') {
19eq.c:         info->p+=2;
19eq.c:    else if(*info->p == '|' && *(info->p+1) == '=') {
19eq.c:         info->p+=2;
19eq.c:    else if(*info->p == '=' && *(info->p+1) != '=') {
19eq.c:         info->p++;
20method.c:    info->current_stack_num++;
20method.c:    string class_name = xsprintf("__current_stack%d__", info->current_stack_num);
20method.c:    sVarTable* vtable = info->lv_table;
20method.c:    vtable = info->lv_table;
20method.c:            string class_name = xsprintf("__current_stack%d__", info->current_stack_num);
20method.c:            info->current_stack_frame_struct = info.classes[class_name];
20method.c:            info->num_method_block++;
20method.c:            method_block2.append_str(xsprintf("%s method_block%d(", make_type_name_string(result_type, false@in_header, false@array_cast_pointer, info), info->num_method_block));
20method.c:            char*% method_block_name = xsprintf("method_block%d", info->num_method_block);
20method.c:            info->current_stack_frame_struct = current_stack_frame_struct;
20method.c:    if(*info->p == '-' && *(info->p+1) == '>') {
20method.c:        info->p +=2;
20method.c:    if(*info->p != '{') {
20method.c:            if(*info->p == ')') {
20method.c:                info->p++;
20method.c:            if(err_flag == false && *info->p == ':') {
20method.c:                info->p++;
20method.c:                info->p = p;
20method.c:                info->sline = sline;
20method.c:            if(*info->p == ',') {
20method.c:                info->p++;
20method.c:            else if(*info->p == ')') {
20method.c:                info->p++;
20method.c:    if(*info->p == '{') {
20method.c:    if(memcmp(info->p, "throws", strlen("throws")) == 0) {
20method.c:        info->p += strlen("throws");
21obj.c:    sType*% type2 = solve_generics(type, info->generics_type, info).catch {
21obj.c:    var type2 = solve_generics(type, info->generics_type, info).catch {
21obj.c:        if(*info->p == '(') {
21obj.c:    else if(buf === "gc_inc" && *info->p == '(') {
21obj.c:         info->p++;
21obj.c:    else if(buf === "gc_dec" && *info->p == '(') {
21obj.c:         info->p++;
21obj.c:    else if(buf === "isheap" && *info->p == '(') {
21obj.c:        info->p++;
21obj.c:        var type2 = solve_generics(param_type, info->generics_type, info) throws;
21obj.c:        if(memcmp(info->p, "comelang", strlen("comelang")) == 0) {
21obj.c:            info->p += strlen("comelang");
21obj.c:        else if(memcmp(info->p, "c", strlen("c")) == 0) {
21obj.c:            info->p += strlen("c");
21obj.c:        else if(memcmp(info->p, "gc", strlen("gc")) == 0) {
21obj.c:            info->p += strlen("gc");
21obj.c:        else if(memcmp(info->p, "no-gc", strlen("no-gc")) == 0) {
21obj.c:            info->p += strlen("no-gc");
21obj.c:        else if(memcmp(info->p, "unsafe", strlen("unsafe")) == 0) {
21obj.c:            info->p += strlen("unsafe");
21obj.c:        else if(memcmp(info->p, "no-null-check", strlen("no-null-check")) == 0) {
21obj.c:            info->p += strlen("no-null-check");
21obj.c:        if(memcmp(info->p, "comelang", strlen("comelang")) == 0) {
21obj.c:            info->p += strlen("comelang");
21obj.c:        else if(memcmp(info->p, "c", strlen("c")) == 0) {
21obj.c:            info->p += strlen("c");
21obj.c:        else if(memcmp(info->p, "gc", strlen("gc")) == 0) {
21obj.c:            info->p += strlen("gc");
21obj.c:        else if(memcmp(info->p, "no-gc", strlen("no-gc")) == 0) {
21obj.c:            info->p += strlen("no-gc");
21obj.c:        else if(memcmp(info->p, "unsafe", strlen("unsafe")) == 0) {
21obj.c:            info->p += strlen("unsafe");
21obj.c:        else if(memcmp(info->p, "no-null-check", strlen("no-null-check")) == 0) {
21obj.c:            info->p += strlen("no-null-check");
21obj.c:    if(memcmp(info->p, "implements", strlen("implements")) == 0) {
21obj.c:        info->p += strlen("implements");
21obj.c:    else if(*info->p == '@') {
21obj.c:        info->p++;
21obj.c:        while(xisalnum(*info->p) || *info->p == '_') {
21obj.c:            info->p++;
22impl.c:        if(*info->p == '<') {
22impl.c:            info->p++;
22impl.c:                if(*info->p == ',') {
22impl.c:                    info->p++;
22impl.c:                else if(*info->p == '>') {
22impl.c:                    info->p++;
22impl.c:                    err_msg(info, "invalid character on impl (%c)", *info->p);
22impl.c:        while(*info->p == '*') {
22impl.c:            info->p++;
22impl.c:        info->impl_type = new sType(word, info);
22impl.c:        info->impl_type->mPointerNum = pointer_num;
22impl.c:        while(*info->p != '}') {
22impl.c:            while(*info->p == ';') {
22impl.c:                info->p++;
22impl.c:        info->impl_type = null;
23interface.c:            if(*info->p == '}') {
23interface.c:                info->p++;
